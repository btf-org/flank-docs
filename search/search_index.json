{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"flank","text":"<p>Flank allows engineers to solve business problems by just writing code.</p> <p>It is a cloud platform + web app that saves engineers from having to think about everything else: what programming language to use, where your code is running, scheduling, a website with logins, user guardrails, CSS rules, audit trails, connecting API calls, building frontends, analytics, compliance.</p> <p>Flank is running in 4 companies. We've been happy with the results so far.</p> <p>If you want to get in touch, shoot us an email at angus@flank.cloud</p>"},{"location":"background/","title":"Backstory","text":""},{"location":"background/#safely-exposing-stored-procs","title":"Safely exposing stored procs","text":"<p>Ad-hoc SQL saved in .txt files on our computer -- that's where we started. We were writing a lot of SQL for business people and we wondered, \"Could we take those text files and turn them into reusable tools?\"</p> <p>We quickly switched from .txt files to stored procedures (named SQL queries). First, we built an API that \"wrapped\", or \"sat on top of\", our stored procs. Then we built a UI layer on top of that, which provided some guardrails for running the stored procs.</p> <p>This app allowed us to expose stored procs to teammates, one at a time.</p>"},{"location":"background/#abstracting-over-apis-too","title":"Abstracting over APIs too","text":"<p>Then we realized that if our API wrapped stored procs, it could wrap any \"function\" that's exposed over the internet -- API endpoints, AWS Lambdas, etc. </p> <p>Next we had users asking for form-controls, like dropdowns. A lot of times the values for the dropdowns came from another stored procedure. So we added a little functionality to \"pipe\" the output of one stored proc into the input of another. We realized that most internal tools (at least, the simple ones) can be modeled as a combination of two stored procedures -- get a table of data, do something to each row.</p>"},{"location":"background/#unexpected-benefits","title":"Unexpected benefits","text":"<p>As we've used the system ourselves, there are a few unexpected benefits we've come to like about it.</p> <p>One is that it's easy to maintain, because if you add a parameter to a stored proc, the Flank API picks up on it, and then the UI updates accordingly.</p> <p>Also, it scales well (better than GUI apps in certain ways) because each stored proc gets its own page and has its own RBAC. In a lot of GUI apps, each incremental feature makes the whole system more complicated.</p> <p>Also it's easy to boot out of. The Flank API \"wraps\" or \"sits on top of\" your stored procs, so there's no lock-in. We've actually used this feature ourselves. We launched a simple product with Flank, one that we've sold into other orgs. And then booted out of it at a certain point.</p>"},{"location":"contact/","title":"Contact Us","text":"<p>If you want to get in touch, shoot us an email at angus@flank.cloud</p>"},{"location":"features/","title":"Features and Benefits","text":"<p>Flank is designed to help with each part of the dev cycle for building an application, tool, etc. From planning through maintaining tools, Flank is there to provide a nice helping hand.</p> <ol> <li>Planning &amp; Design</li> <li>Coding &amp; Development</li> <li>Testing and Quality Assurance</li> <li>Deployment &amp; Operations</li> <li>Maintencance and Scaling</li> </ol>"},{"location":"features/#planning-and-design","title":"Planning and Design","text":""},{"location":"features/#usage-tracker-across-tools","title":"Usage Tracker across tools","text":"<p>Flank tracks the usage of tools through a couple of key metrics like \u201cruns over time\u201d, \u201cnumber of unique users\u201d, etc. These help you figure out lots of next decisions like:  - Tools that are used a lot, so they could benefit from a custom UI  - Tools that could benefit other parts of the org</p>"},{"location":"features/#delay-front-end-design","title":"Delay Front-end Design","text":"<p>With Flank, there\u2019s no need to design a UI when first building a tool. Instead focus on getting the business logic right and work with your users to see how they interact with the tool. Given that feedback, you (or your designers) will be able to create a better custom Ui after some initial usage. This enables you to build the best UI for tools that deserve it and stops over designing for tools which don\u2019t need it.</p>"},{"location":"features/#coding-and-development","title":"Coding and Development","text":""},{"location":"features/#instant-ui-development","title":"Instant UI development","text":"<p>You write the backend business logic, Flank builds the Ui and creates a webpage for your teammates or users to access it.</p>"},{"location":"features/#testing-and-quality-assurance","title":"Testing and Quality Assurance","text":""},{"location":"features/#bug-reporting-system","title":"Bug reporting system","text":"<p>Flank incorporates an intuitive bug reporting system that facilitates the identification, tracking, and resolution of software bugs. This system helps maintain high-quality standards by ensuring that issues are promptly addressed and resolved, enhancing the reliability of your tools.</p>"},{"location":"features/#deployment-and-operations","title":"Deployment and Operations","text":""},{"location":"features/#flank-handles-the-hosting-for-the-ui","title":"Flank handles the hosting for the UI","text":"<p>Flank simplifies the deployment process by managing the hosting of your tool's UI. This eliminates the need for complex server setups and reduces the operational burden on your team.</p>"},{"location":"features/#built-in-auth-management-system","title":"Built-in Auth Management System","text":"<p>Flank comes equipped with a built-in authentication management system that secures access to your tools. It manages user identities and ensures that only authorized users can access specific functions, enhancing security and compliance.</p>"},{"location":"features/#automatic-updates-for-tools","title":"Automatic updates for tools","text":"<p>Flank supports the continuous improvement of tools by automatically applying updates. This feature ensures that all tools remain current with the latest features and security patches, minimizing downtime and maintaining operational efficiency.</p>"},{"location":"features/#maintenance-and-scaling","title":"Maintenance and Scaling","text":""},{"location":"features/#file-folder-management-system","title":"File &amp; Folder Management System","text":"<p>Flank includes a comprehensive file and folder management system that organizes and secures digital assets. This system supports efficient scaling by ensuring that resources are well-managed and accessible as your tools grow.</p>"},{"location":"features/#templated-ui-for-easy-re-use","title":"Templated UI for easy re-use","text":"<p>Flank offers a range of UI templates that can be easily customized and reused across different tools. This not only speeds up the development process but also ensures a consistent user experience across your toolkit.</p>"},{"location":"goals/","title":"Goals and Core Concepts","text":""},{"location":"goals/#dont-overinvest-in-ui","title":"Don't overinvest in UI","text":""},{"location":"goals/#get-leverage-out-of-one-off-fixes","title":"Get leverage out of one-off fixes","text":"<p>With those goals in mind, we set out to build a dashboard / app / tool builder that\u2026</p> <ol> <li>Had an upfront cost close to 0</li> <li>Covered 90% of our internal tooling / dashboarding / admin panel use cases</li> <li>Provided out-of-the-box guardrails and access control</li> <li>Allowed the engineers to quickly figure out who did what whenever things did go wrong</li> </ol>"},{"location":"hosting/","title":"Hosting, Security, and PII","text":""},{"location":"hosting/#code-executes-in-your-cloud","title":"Code executes in your cloud","text":"<p>When a user runs a stored procedure through Flank, the stored procedure executes on the database, and Flank merely returns the result. Same thing with an API call or an AWS Lambda. </p>"},{"location":"hosting/#results-are-stored-in-your-cloud","title":"Results are stored in your cloud","text":"<p>Flank stores the result of each run. The most common setup is to store the result in your cloud, either in AWS S3 or Azure Blob Storage.</p>"},{"location":"hosting/#you-control-flanks-permissions","title":"You control Flank's permissions","text":"<p>Flank has one entrypoint into your services, which you control. If you're using it with a database, you can create a database role specifically for Flank. If you're using it with AWS Lambda, you can create an AWS role specifically for Flank.</p> <p>Basically, Flank needs two permissions:</p> <ol> <li>An ability to \"read\" or gain awareness of stored procedures</li> <li>An ability to execute whichever ones you want to expose</li> </ol> <p>Additionally, if you're storing the run results in your cloud (see above), Flank needs permissions to read/write to a bucket that you create.</p>"},{"location":"hosting/#you-can-host-flank-yourself","title":"You can host Flank yourself","text":"<p>Flank consists of 1) a single page app, 2) an API, 3) a database. If you want, you can host all three in your cloud.</p>"},{"location":"hosting/#pii-can-be-flagged-and-deleted","title":"PII can be flagged and deleted","text":"<p>Flank stores the results of queries that users run (see above). These queries can contain PII. Depending on your retention policy, queries that contain PII can be flagged as such, and their results can be deleted on a rolling basis. For user-requested deletions, the results can be searched and deleted.</p>"},{"location":"how-does-it-work/","title":"How Does It Work?","text":""},{"location":"how-does-it-work/#step-by-step","title":"Step by Step","text":"<ol> <li>Deploy - You deploy a stored procedure (or API endpoint) on your infra</li> <li>Diff - In Flank, you run a diff against your database (or Swagger Doc)</li> <li>Commit. - Flank imports metadata about the input parameters</li> <li>Share/Run - You share the function with a teammate, and they run it on their own</li> </ol>"},{"location":"how-does-it-work/#further-steps","title":"Further steps","text":"<ul> <li>Dropdowns - Either hardcoded or populated by the output of another function</li> <li>Tables with buttons - Wire up the outputs of one function to the input of another</li> <li>Cron - Run stored procedures (or API endpoints) on a schedule</li> </ul>"},{"location":"just-write-code/","title":"Just write code","text":"<p>Just write code.</p> <p>That is the idea behind Flank.</p> <p>We've lost the ability to solve simple business problems because we're swamped with tools and meetings.</p> <p>Just write code.</p> <p>To use Flank, write a script and push it to GitHub. That's it. It'll show up in the Flank web app, you can run it, and it'll just work.</p> <p>Just write code.</p> <p>You could also wire up an API or a database \u2014 really, anything that can be containerized or run over the internet. Flank doesn't care whether the code runs on your infrastructure or ours.</p> <p>Just write code.</p> <p>Once Flank has discovered your script, you can run it on a schedule. You don't have to deal with an scheduling tool.</p> <p>Just write code.</p> <p>At some point you'll be asked to manually re-run that script. But it's crazy for you to be on-call all the time.  And even crazier to build a whole website with logins and guardrails.</p> <p>Flank automatically creates UI around your script. Datepickers for input, tables for output. It's intuitive for users, and incredibly fast for developers.</p> <p>Just write code.</p> <p>Sometimes your teammate will fat-finger an input. It's easy to drill into what happened. You don't have to build audit trails for tracking down errors.</p> <p>Just write code.</p> <p>You can even set up automated alerts by piping the output into another task (e.g. PagerDuty API call). You don't have to write any code to pipe a script into an API call.</p> <p>Just write code.</p> <p>The ability to connect two tasks is quite powerful. Get a list of X and then take some action on X is a common pattern. In this way, Flank lets you build apps for non-technical teammates.</p> <p>Just write code.</p> <p>Once people are using Flank, the product team will want insights into user behavior. Flank provides analytics on who does what,  when. You don't have to build any instrumentation.</p> <p>Just write code.</p> <p>As your company grows, your engineering manager will want to stay compliant. Flank makes it easy to configure that. </p> <p>Just write code.</p> <p>There is no DDL or YAML or learning curve for any of this. You (the engineer) are the scarce resource. You shouldn't have to spent time learning yet another tool.</p> <p>Just write code.</p> <p>Flank houses no \"application logic\" at all. No loops, no conditionals. There's no lock-in because you control your code. You can even host Flank yourself.</p> <p>Just write code. \u270c</p> <p>Flank is all about what you don't have to think about: what programming language to use, where your code is running, scheduling, a website with logins, user guardrails, CSS rules, audit trails, connecting API calls, building frontends, analytics, compliance.</p>"},{"location":"miscellaneous/","title":"Miscellaneous","text":""},{"location":"miscellaneous/#our-stack","title":"Our stack","text":"<p>On the frontend, we use Vue, Tailwind, Buefy, and Typescript. We\u2019re particularly fond of a VSCode extension called JavaScript REPL, which provides a live REPL inside JS files.</p> <p>On the backend, we use Python, FastAPI, Pydantic, SQLAlchemy and Postgres. We make extensive use of iPython, which combined with VSCode, allows us to shoot our code into the REPL, a la SLIME from the EMacs world. We've also built an \"entity\" abstraction on top of SQLAlchemy and FastAPI that is trying to solve the same problem as EdgeDB. Big fan of FastAPI. Super easy to dive in and read the source code. </p> <p>We host the frontend in S3 (AWS) and Static Web Apps (Azure). We host the backend in Lambda (AWS) and Function Apps (Azure).</p>"},{"location":"miscellaneous/#tools-that-inspire-us","title":"Tools that inspire us","text":"<p>There are two tools that really influenced the way we think about programming. One is Unix pipes and the other is Jupyter Notebooks/REPLs. Then, from a UI/UX perspective, we really like how Notion does all the simple things really well and just gets out your way. In a weird way, Flank is sort of a mashup of those three things.</p>"},{"location":"miscellaneous/#motivation","title":"Motivation","text":"<p>All of us were, at some point, engineers who were relied on to run stuff. We were turning into human run buttons, and that was annoying. The thinking was something like, Once there's code in the cloud/database, shouldn't it be easy for anyone to run it? To recombine it with other programs?</p>"},{"location":"results/","title":"Results so far","text":"<p>Flank is running in 4 companies: </p> <ul> <li>1-person data science operation</li> <li>10-person SaaS company</li> <li>60-person SaaS company</li> <li>350-person marketplace (with a warehouse)</li> </ul> <p>In a way, we've been surprised -- even at different sizes/stages, the effect of Flank has been the same:</p> <p>Eliminating tools, meetings, and messages.</p> <p>At a 1-person data science operation, the Data Scientist had to dive into AWS whenever an R script needed to be run in parallel, or on a schedule, or on a machine with more memory.</p> <p>With Flank, he just writes R scripts. No AWS.</p> <p>Eliminating tools, meetings, and messages.</p> <p>At a 10-person company, the Sales team needed to get up-to-the-minute predictions from a model. Before, they had a React app built by consultants. The consultants were slow, so their in-house Data Engineer had to manually service a lot of these data requests.</p> <p>With Flank, their Data Engineer can deliver reusable tools without using the consultants.</p> <p>Eliminating tools, meetings, and messages.</p> <p>At a 60-person company, the Customer Service team couldn't wait for apps to get built, so they would resolve problems by manually triggering API calls in Postman. They were working in JSON, making errors, Slacking engineers for API keys... it was a mess.</p> <p>With Flank, they can quickly wire together API calls to make safe, reusable apps. They don't have to think about API keys or JSON or HTTP methods.</p> <p>Eliminating tools, meetings, and messages.</p> <p>At a 350-person marketplace (with a warehouse), every little feature required a meeting between a PM, a designer, a React Developer, a Database Engineer, and an API engineer. Also, their Database Engineers were swamped with urgent requests from the Operations team.</p> <p>With Flank, they ship like they're a small startup again. Their Database Engineer can deliver reusable tools as quickly as he can service ad-hoc requests. He can schedule jobs and set up alerts without any Azure help. And he can iterate with users directly, without a PM having to intermediate.</p> <p>Eliminating tools, meetings, and messages. \u270c</p>"},{"location":"tech-debt/","title":"No tech debt?","text":"<p>Flank is inspired by the previous generations of internal tool builders, but it's designed to address some of their shortcomings when it comes to scaling.</p>"},{"location":"tech-debt/#no-code-seep","title":"No \"code seep\"","text":"<p>You don't write any code in Flank. You write code in your IDE and deploy it with your CI/CD. Flank is just a proxy for running it on your infrastructure.</p>"},{"location":"tech-debt/#no-lock-in","title":"No lock-in","text":"<p>There is effectively zero \"app logic\" in Flank. No extra JS \"glue\", no loops, no conditionals. You could put 100 stored procedures into Flank, throw Flank out the window, and you'd still have your 100 stored procedures.</p>"},{"location":"tech-debt/#no-design-debt","title":"No design debt","text":"<p>There's no drag-and-drop in Flank. Nothing to design. You won't create any Frankenstein UIs that require a whole wiki to onboard new hires.</p>"},{"location":"tech-debt/#no-2-d-permissioning-complexity","title":"No 2-D permissioning complexity","text":"<p>No conditionally rendered components if <code>userLevel == 'intern'</code>. Flank is organized at the level of individual queries/endpoints. Everything is permissioned at that level.</p>"},{"location":"tech-debt/#no-breaking-changes","title":"No breaking changes","text":"<p>Flank stays in sync with changes to backend code (via an API schema or RDBMS metadata), so if you add or remove a parameter, you don't have to worry about your internal tool being decoupled and out of sync.</p>"},{"location":"tech-debt/#deprecate-with-confidence","title":"Deprecate with confidence","text":"<p>\"Is it safe to deprecate this stored procedure? When was the last time anyone used it...?\" Flank provides out-of-the-box analytics on who ran what, and when they ran it.</p>"},{"location":"tech-debt/#track-down-errors-quickly","title":"Track down errors quickly","text":"<p>If a button doesn't work in a React app, it takes a small army of people (and JIRA tickets) to figure out which API call failed. In Flank, you just look at failed executions and you can see exactly which call failed and what the user's input was.</p>"},{"location":"tech-debt/#arbitrarily-large-datasets","title":"Arbitrarily large datasets","text":"<p>Most internal tool builders are simply replacements for your frontend, so they're constrained by browser memory. If Flank encounters a large dataset, it saves the data behind the scenes and only returns a truncated version to the frontend. Users can then download the full version to file.</p>"},{"location":"tech-debt/#manage-pii-deletion-location","title":"Manage PII deletion / location","text":"<p>If there's an endpoint/query that returns PII, you can flag it and have Flank auto-delete the data after a certain time period. If you have European data, and you have BLOB storage hooked up in a European availaiblity zone, you can just point and click and tell Flank to store the data there.</p>"},{"location":"tradeoffs/","title":"Design Decisions and Tradeoffs","text":""},{"location":"tradeoffs/#no-deployment","title":"No deployment","text":"<p>Flank doesn't help with deploying SQL / backend code / scripts.</p> <p>We started with SQL in .txt files on our computer. Initially we thought, \"Let's get those text files hosted somewhere!\" But then we realized it was simpler to just save all our SQL as stored procedures, and for Flank to sit on top of the DB. Also, a lot of people a lot smarter than us have put a lot of thought into how make deployment better...</p> <p>Pro: Flank has one job</p> <p>Con: You need to figure out some deployment stuff on your own</p>"},{"location":"tradeoffs/#no-coding","title":"No coding","text":"<p>Flank is not a tool where engineers write code</p> <p>Once we built the Flank interface and we had a database connection set up, it was tempting to say, \"Let's just write some SQL here in the browser so we don't have to pop into another app...\" </p> <p>Pro: Backend code remains under your control, and there's no temptation to write it in Flank</p> <p>Con: It's harder to write a little code to fix this or that</p>"},{"location":"tradeoffs/#no-loops-or-conditionals","title":"No loops or conditionals","text":"<p>Flank is not a low-code/visual programming tool</p> <p>Once we added the ability to put two (or three) stored procedures on the page, there was a temptation to add the ability to do things like: Based on the result of stored procedure A, either execute B or C. But there are lots of tools out there solving this problem -- Azure Logic Apps, AWS Step Functions, Airflow, Pipedream. Not to mention the aforementioend logic could be wrapped up in a fourth stored procedure, D, and then that could be exposed.</p> <p>Pro: App logic remains under your control, and there's no temptation to let it sneak into Flank</p> <p>Con: You can't quickly upgrade from a manual runbook to a nifty automation</p>"},{"location":"tradeoffs/#no-conditional-ui","title":"No conditional UI","text":"<p>Flank doesn't support conditional or interactive UI</p> <p>Imagine you're building a booking system that presents a user with \"Would you like to book a flight, hotel or car?\" And then, based on their choice, different options appear below. Flank doesn't support the conditional rendering of UI. Our attitude is that there are already great tools and frameworks for building an app like that. Our philosophy has beeen to make the simple things fast, and to make it easy to \"boot out\" into another tool when an app outgrows Flank.</p> <p>Pro: Flank doesn't creep into the tweener zone, where you're tempted to keep using it when you should just build a React app or something</p> <p>Con: At some point, you'll be compelled to \"boot out\" of Flank</p>"},{"location":"tradeoffs/#no-logging-sort-of","title":"No logging (sort of)","text":"<p>Flank doesn't display logs out of the box</p> <p>We had some long-running tasks where it would have been helpful to see the logs in Flank. We were tempted to figure out some way to automatically pipe them into Flank. However, Flank is intended to be consumed by business people. Logs are for engineers. Instead, we added the ability for a task to explicitly write \"logs\" back to Flank.</p> <p>Pro: Keeps interface user-friendly for business people</p> <p>Con: Occasionally requires user to write code specifically to make something work with Flank, and, in this case, results in two sets of logging statements</p>"},{"location":"tradeoffs/#15-minute-timeout","title":"15 minute timeout","text":"<p>Flank's backend is hosted in Lambda, which as a 15 minute timeout per request</p> <p>When a user clicks the \"run\" button on a stored procedure, the Flank API just calls the stored proc on behalf of the user. That request has a 15 minute timeout. So Flank will lose track of any queries that take longer than 15 minutes. There was a temptation to simply host Flank in a container on a service with no timeout, like Fargate.</p> <p>We decided to keep the backend in a Lambda and allow users to \"write back\" results for tasks that take longer than 15 minute. This requires users to write some code of their own to support Flank usage, which ruins a bit of the magic (and the claim that we're 100% decoupled). The reasoning was that, generally speaking, we should focus on supporting the 80% use cases out of the box, and then we should support the long tail of random stuff by making the system more hackable.</p> <p>Pro: Makes our lives cheaper/simpler, which doesn't directly help you, but it allows us to move faster on the important stuff</p> <p>Con: Occasionally requires user to write code specifically to make something work with Flank</p>"},{"location":"use-cases/","title":"Use Cases","text":""},{"location":"use-cases/#level-1-access-and-guardrails","title":"Level 1 - Access and Guardrails","text":"<ul> <li>Access - Safely give non-engineers access to...<ul> <li>Frequently-run queries</li> <li>Re-running failed jobs</li> <li>Urgent CRUD operations</li> </ul> </li> <li>Guardrails - Quickly configure things like...<ul> <li>Null-handling, min/max, etc.</li> <li>Dropdowns that are either hardcoded or populated by other functions</li> </ul> </li> </ul>"},{"location":"use-cases/#level-2-automation-and-combination","title":"Level 2 - Automation and Combination","text":"<ul> <li>Cron - Set functions to run on a schedule</li> <li>Bulk Runs - Run functions over a list of inputs</li> <li>Tables and Buttons - Wire up the outputs of one function to the inputs of another</li> </ul>"},{"location":"use-cases/#level-3-integration","title":"Level 3 - Integration","text":"<ul> <li>Flank API - Analyze usage in another tool, trigger functions with AI Agents, etc.</li> </ul>"},{"location":"use-cases/#_1","title":"Use Cases","text":""},{"location":"comparisons/all-comparisons/","title":"Comparisons","text":"<p>Flank is like a barebones Retool, or Postman with guardrails, or SwaggerUI on steroids.</p> Comparison Description Retool Flank is laser-focused on making one Retool use case as smooth as possible, which is: creating some input fields, wiring them up to a SPROC/API endpoint, displaying the results in a table, then attaching buttons to each row. Flank does all that automatically, but that's all it does. Retool offers UI/UX flexibility that is much closer to a React app. Flank is closer to Postman. Power Apps See Retool Budibase See Retool Slackbots Flank and Slackbots are kindred spirits. The difference comes down to UI + RBAC. Flank has input fields with guardrails, and it show the results in tables. Also, everything is permissioned at the function level. Slackbots are much better-suited for any problems that fit into a messaging paradigm. React &amp; SPAs With Flank you get 1) hosting, 2) SSO, 3) RBAC, 4) autogenerated input fields, and 5) audit trails. But there's zero customization of the UI (aside from adding guardrails). If you need to build 50 pages that look like a Google Form, use Flank for that. Rails &amp; SSRs See React Postman Imagine Postman, but with an interface for a business person. Inputs with guardrails. That's Flank. Flank can tackle more complex apps use cases too... You can put buttons on tables by wiring up the output of one function to the input of another. SwaggerUI Flank is basically SwaggerUI, but for engineers to collaborate with business people. It has RBAC and a user-friendly interface. Also it does things like storing run results so that users can download them. And Flank can tackle more complex use cases as well. Like you can put buttons on tables by wiring up the output of one function to the input of another. PopSQL Flank is also organized around the idea of a library of queries. But Flank is not a SQL IDE. It is laser-focused on one part of the development process, which is safely exposing a written SPROC to a non-engineer. It can also do more \"app-ish\" things, like feeding the outputs into the inputs of another (i.e. tables with buttons on the rows). Snowflake Worksheets Flank is designed for business people. They don't see any raw SQL when they trigger a SPROC/API endpoint. It's just simple UI with guardrails. Tableau Flank is for urgent, straight-to-Excel reports, not pretty visualizations. Also, Flank can trigger SPROCs/API endpoints that write back to the database. PowerBI See Tableau Looker See Tableau Metabase See Tableau Streamlit Flank doesn't do interactive data visualization stuff. It is simply a tool for turning a SPROC/API endpoint into a webpage with guardrails. It's agnostic to how the function is written as long as it's callable over the internet. Zapier Flank is for use cases where a human needs to go click a button. dbt Flank has a little pipelineing/orchestration ability, but, really, it's designed for situations where a human needs to go click a button to get some data or update some data or re-run something. Pipedream Flank is for use cases where a human needs to go click a button."},{"location":"deprecated/motivations/","title":"Persistent grumblings","text":""},{"location":"deprecated/motivations/#urgent-requests","title":"Urgent requests","text":"<p>AKA burning TF out as the fix-it guy.</p> <p>We all worked at companies that relied on the engineers to fix things. A quick query. Kicking off a job that failed. Changing a value in the database.</p> <p>Dealing with these requests sucked \ud83e\udd2e, but it was better than the alternatives. Giving people access to the database could create WAY more work. And building them an app to do the job wasn\u2019t worth it, especially for just that once.</p> <p>But it always starts with just that one time\u2026 at what point do you build an app? The third time? The tenth time?</p> <p>We wondered to ourselves, \u201cIs there a way we could get leverage on these so-called 'one-off' fixes?\u201d</p>"},{"location":"deprecated/motivations/#requirements-change","title":"Requirements change","text":"<p>AKA watching the tools we just built get thrown away because the boss changed his mind</p> <p>When we did commit to building tools, half the time they\u2019d get thrown away. Either the spec made no sense, or the business focus would change, or someone from another department would step into a meeting and say, \u201cWe\u2019ve already got something that solves this problem.\u201d \ud83d\ude21</p> <p>We wondered to ourselves, \u201cIs there a way to prototype features more quickly? To build less while still learning the same amount?\u201d</p>"},{"location":"deprecated/motivations/#the-hydra","title":"The Hydra","text":"<p>AKA how could a user possibly thought to do that?</p> <p>We built tools to take ourselves out of the loop, but then\u2026 The tools would go down. Our users would punch a string into a field that required an int. The backend API would change and the frontend would be out of date. Everything we built would somehow generate more work, not less. \ud83d\ude29</p> <p>We wondered to ourselves, \u201cCould we templatize guardrails in some way? Could we make it easier to get visibility into the system?\u201d</p>"},{"location":"deprecated/unexpected/","title":"Unexpected benefits","text":""},{"location":"deprecated/unexpected/#more-use-cases-than-we-realized","title":"More use cases than we realized","text":"<p>Initially, we had built a system that allowed business people to safely execute one stored procedure at a time, without the engineer having to build any UI. This was interesting and sort of useful, but the use cases were fairly limited. </p> <p>As we kept running into problems that we wanted immediately solutions for, we realized two things:</p> <ol> <li>If we could do stored procs, we could also do APIs - Once you abstract over a stored procedure, you've really abstracted over any function that can be invoked over the internet (API endpoint, AWS Lambda, etc.)</li> <li>\"Pipes\" opened up a whole world of applications - If you could figure out a way to \"pipe\" the output of a function into the input of another, that actually covers a lot of business use cases, like maybe 90%?</li> </ol>"},{"location":"deprecated/unexpected/#easy-to-maintain","title":"Easy to maintain","text":"<p>Decoupled architectures are great and everything, but one of the annoying things is when the API interface changes and you have to rewire the frontend. Flank doesn't have the problem, since the UI is derived from the backend code. If the backend code changes, you just \"refresh\" everything in Flank.</p>"},{"location":"deprecated/unexpected/#scales-well","title":"Scales well","text":"<p>In most web apps, the relationship between features and complexity is something like O(n^2). UI starts to clutter the screen. RBAC becomes complicated. Next thing you know, new employees have to be \"trained\" on the tool...</p> <p>Flank is way simpler, for better or worse. Each stored procedure has it's own web page and it's own set of permissions. They're all independent of one another. Adding a new stored proc just makes the list grow longer. It's more like O(n).  </p>"},{"location":"deprecated/unexpected/#no-lock-in","title":"No lock-in","text":"<p>Flank merely \"sits on top of\" or \"wraps\" existing stored procedures. There's no app logic in Flank. If you were to stop using Flank, your stored procedure would be right where you left it.</p>"},{"location":"deprecated/unexpected/#latent-demand","title":"Latent demand","text":"<p>If you give a mouse a cookie, he's going to ask for a glass of milk. Similarly, if you give a business person a button, they're going to press that thing a million times. </p>"},{"location":"deprecated/v1/","title":"A modest MVP","text":""},{"location":"deprecated/v1/#local-sql-stash-reusable-tools","title":"Local SQL stash =&gt; Reusable tools...?","text":"<p>We were frustrated about being the gatekeepers, the fix-it guys, the human run buttons \ud83e\udd16. And our first idea was to take all those ad-hoc SQL queries that lived in text files on our computers and to turn them into reusable tools for everyone at our company.</p>"},{"location":"deprecated/v1/#design-goals","title":"Design goals","text":"<ol> <li>Desired workflow: write SQL, get a new tool instantaneously</li> <li>Out-of-the-box guardrails and RBAC</li> <li>History of everything that happened</li> </ol>"},{"location":"deprecated/v1/#a-simple-workflow","title":"A simple workflow","text":"<p>We found that we could build this system pretty easily if we just wrote stored procs. </p> <p>We thought this was neat because it was simpler than the old way of doing things, where we would either 1) turn into the gatekeeper for urgent data requests, 2) build a frontend to expose the query. </p>"},{"location":"deprecated/v1/#dont-you-still-have-to-write-the-sql","title":"Don't you still have to write the SQL?","text":"<p>Yes. This system saved us from repeatedly running things for other people and repeatedly building simple UI. </p>"},{"location":"integrations/all-integrations/","title":"Technical Details","text":"Current Roadmaped Things that can be run MSSQL Stored ProcsAWS LambdaAWS Step FunctionsREST APIs Azure Function Apps Places where results can be stored Azure BLOBAWS S3 SSO Active Directory"},{"location":"integrations/az-functions/","title":"Azure Function Apps","text":""},{"location":"integrations/lambda/","title":"AWS Lambda","text":"<p>To expose your SQL Server stored procedure or function on Flank, follow these steps.</p>"},{"location":"integrations/lambda/#1-create-a-role-for-flank-in-aws","title":"1. Create a role for Flank in AWS","text":"<ol> <li>Navigate to IAM</li> <li>Create new role</li> <li>Select AWS Account for Trusted entity type</li> <li>Select Require external ID. Name the external ID whatever you\u2019d like.</li> <li>Select AWSLambda_FullAccess</li> <li>Create role</li> </ol>"},{"location":"integrations/lambda/#2-add-your-resource-for-the-first-time","title":"2. Add your resource for the first time","text":"<ol> <li>Navigate to Flank and click Add Resource, then AWS</li> <li>Nickname - Anything you want</li> <li>Fill in your newly created role\u2019s arn</li> <li>Fill in your newly created role\u2019s external Id</li> <li>TODO - S3</li> <li>Add resource</li> </ol>"},{"location":"integrations/lambda/#3-add-your-lambda-to-flank","title":"3. Add your Lambda to Flank","text":"<ol> <li>Sync Commands</li> <li>Click on your newly added resource</li> <li>Choose which lambdas you\u2019d like to add</li> <li>Add to my workspace</li> </ol>"},{"location":"integrations/lambda/#4-configuring-your-command","title":"4. Configuring your command","text":""},{"location":"integrations/lambda/#5-running-your-command","title":"5. Running your command","text":""},{"location":"integrations/lambda/#6-share-your-command","title":"6. Share your command","text":""},{"location":"integrations/lambda/#7-see-its-history","title":"7. See its history","text":""},{"location":"integrations/mssql/","title":"SQL Server","text":"<p>To expose your SQL Server stored procedure or function on Flank, follow these steps.</p>"},{"location":"integrations/mssql/#1-add-your-resource-for-the-first-time","title":"1. Add your resource for the first time","text":"<ol> <li>Navigate to Flank and click Add Resource</li> </ol>"},{"location":"integrations/mssql/#2-fill-out-the-following-fields","title":"2. Fill out the following fields","text":"<ol> <li>Nickname - can be whatever you\u2019d like</li> <li>Creds for the database<ol> <li>Username</li> <li>Password</li> <li>Host</li> <li>Port</li> <li>Database name</li> <li>Database system - TODO</li> </ol> </li> <li>Alternatively, you can use a connection string with the aforementioned fields</li> <li>TODO - is public</li> </ol>"},{"location":"integrations/mssql/#3-add-your-stored-procedure-to-flank","title":"3. Add your stored procedure to Flank","text":"<ol> <li>Sync Commands</li> <li>Click on your newly added resource</li> <li>Choose which stored procedures you\u2019d like to add</li> <li>Add to my workspace</li> </ol>"},{"location":"integrations/mssql/#4-configuring-your-command","title":"4. Configuring your command","text":""},{"location":"integrations/mssql/#5-running-your-command","title":"5. Running your command","text":""},{"location":"integrations/mssql/#6-share-your-command","title":"6. Share your command","text":""},{"location":"integrations/mssql/#7-see-its-history","title":"7. See its history","text":""},{"location":"integrations/rest/","title":"REST APIs","text":""},{"location":"quickstarts/jupyter-fastapi/","title":"Quick Start","text":"<p>In this example, we'll create a dashboard and a tool using Flank. To simulate a real backend, we're going to first create a simple API. The whole process should only take about 5 minutes.</p> <ol> <li>Download a Jupyter Notebook with all the code.</li> <li>Upload it to Google Colab. See below. </li> <li>Follow instructions in notebook.</li> </ol> <p></p> <p>If you run into any problems, you can email us at angus@flank.cloud. If you want to view the code in your browser or clone the repo and run locally, click here.</p>"}]}